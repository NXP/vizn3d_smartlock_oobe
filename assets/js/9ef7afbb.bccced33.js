"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[992],{3905:function(e,t,n){n.d(t,{Zo:function(){return f},kt:function(){return h}});var a=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var o=a.createContext({}),d=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},f=function(e){var t=d(e.components);return a.createElement(o.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,i=e.originalType,o=e.parentName,f=r(e,["components","mdxType","originalType","parentName"]),p=d(n),h=s,m=p["".concat(o,".").concat(h)]||p[h]||c[h]||i;return n?a.createElement(m,l(l({ref:t},f),{},{components:n})):a.createElement(m,l({ref:t},f))}));function h(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var i=n.length,l=new Array(i);l[0]=p;var r={};for(var o in t)hasOwnProperty.call(t,o)&&(r[o]=t[o]);r.originalType=e,r.mdxType="string"==typeof e?e:s,l[1]=r;for(var d=2;d<i;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},9398:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return o},metadata:function(){return d},toc:function(){return f},default:function(){return p}});var a=n(7462),s=n(3366),i=(n(7294),n(3905)),l=["components"],r={sidebar_position:8},o="Flash Devices",d={unversionedId:"framework/hal_devices/flash",id:"framework/hal_devices/flash",isDocsHomePage:!1,title:"Flash Devices",description:"The flash HAL device represents an abstraction used to implement a device which handles all operations dealing with flash (permanent) storage.",source:"@site/docs/framework/hal_devices/flash.md",sourceDirName:"framework/hal_devices",slug:"/framework/hal_devices/flash",permalink:"/vizn3d_smartlock_oobe/docs/framework/hal_devices/flash",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"Low Power Devices",permalink:"/vizn3d_smartlock_oobe/docs/framework/hal_devices/low_power"},next:{title:"Overview",permalink:"/vizn3d_smartlock_oobe/docs/framework/events/overview"}},f=[{value:"Device Definition",id:"device-definition",children:[],level:2},{value:"Operators",id:"operators",children:[{value:"Init",id:"init",children:[],level:3},{value:"Deinit",id:"deinit",children:[],level:3},{value:"Format",id:"format",children:[],level:3},{value:"Save",id:"save",children:[],level:3},{value:"Append",id:"append",children:[],level:3},{value:"Read",id:"read",children:[],level:3},{value:"Make Directory",id:"make-directory",children:[],level:3},{value:"Remove",id:"remove",children:[],level:3},{value:"Rename",id:"rename",children:[],level:3},{value:"Cleanup",id:"cleanup",children:[],level:3}],level:2},{value:"Example",id:"example",children:[{value:"Littlefs Device",id:"littlefs-device",children:[],level:3}],level:2}],c={toc:f};function p(e){var t=e.components,n=(0,s.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"flash-devices"},"Flash Devices"),(0,i.kt)("p",null,"The flash HAL device represents an abstraction used to implement a device which handles all operations dealing with flash",(0,i.kt)("sup",{parentName:"p",id:"fnref-1"},(0,i.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))," (permanent) storage."),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},(0,i.kt)("sup",{parentName:"p",id:"fnref-1"},(0,i.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),' Even though the word "flash" is used in the terminology of this device,\nthe user is technically capable of implementing a FS which uses a volatile memory instead.\nOne potential reason for doing so would be to run logic/sanity checks on the filesystem API\'s before implementing them on a flash device.'),(0,i.kt)("p",{parentName:"div"},"Ultimately, the flash HAL device is useful for abstracting not only flash operations, but memory operations in general."))),(0,i.kt)("p",null,"The flash HAL device is primarily used as a wrapper over an underlying filesystem,\nbe it LittleFS, FatFS, etc.\nAs a result,\nthe ",(0,i.kt)("a",{parentName:"p",href:"/vizn3d_smartlock_oobe/docs/framework/device_managers/flash_manager"},"Flash Manager")," only allows one flash device to be registered because there is usually no need for multiple file systems operating at the same time."),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Because only one flash device can be registered at a time,\nthis means that API calls to the ",(0,i.kt)("a",{parentName:"p",href:"/vizn3d_smartlock_oobe/docs/framework/device_managers/flash_manager"},"Flash Manager")," essentially act as wrappers over the flash HAL device's operators."))),(0,i.kt)("p",null,"In terms of functionality,\nthe flash HAL device provides:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Read/Write operations"),(0,i.kt)("li",{parentName:"ul"},"Cleanup methods to handle defragmentation and/or emptying flash sectors during idle time"),(0,i.kt)("li",{parentName:"ul"},"Information about underlying flash mapping and flash type")),(0,i.kt)("h2",{id:"device-definition"},"Device Definition"),(0,i.kt)("p",null,"The HAL device definition for flash devices can be found under ",(0,i.kt)("inlineCode",{parentName:"p"},"framework/hal_api/hal_flash_dev.h")," and is reproduced below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="framework/hal_api/hal_flash_dev.h"',title:'"framework/hal_api/hal_flash_dev.h"'},"/*! @brief Attributes of a flash device */\nstruct _flash_dev\n{\n    /* unique id */\n    int id;\n    /* operations */\n    const flash_dev_operator_t *ops;\n};\n")),(0,i.kt)("p",null,"The device ",(0,i.kt)("a",{parentName:"p",href:"#operators"},"operators")," associated with flash HAL devices are as shown below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"/*! @brief Callback function to timeout check requester list busy status. */\ntypedef int (*lpm_manager_timer_callback_t)(lpm_dev_t *dev);\n\n/*! @brief Operation that needs to be implemented by a flash device */\ntypedef struct _flash_dev_operator\n{\n    sln_flash_status_t (*init)(const flash_dev_t *dev);\n    sln_flash_status_t (*deinit)(const flash_dev_t *dev);\n    sln_flash_status_t (*format)(const flash_dev_t *dev);\n    sln_flash_status_t (*save)(const flash_dev_t *dev, const char *path, void *buf, unsigned int size);\n    sln_flash_status_t (*append)(const flash_dev_t *dev, const char *path, void *buf, unsigned int size, bool overwrite);\n    sln_flash_status_t (*read)(const flash_dev_t *dev, const char *path, void *buf, unsigned int size);\n    sln_flash_status_t (*mkdir)(const flash_dev_t *dev, const char *path);\n    sln_flash_status_t (*rm)(const flash_dev_t *dev, const char *path);\n    sln_flash_status_t (*rename)(const flash_dev_t *dev, const char *OldPath, const char *NewPath);\n    sln_flash_status_t (*cleanup)(const flash_dev_t *dev, unsigned int timeout_ms);\n} flash_dev_operator_t;\n\n")),(0,i.kt)("h2",{id:"operators"},"Operators"),(0,i.kt)("p",null,'Operators are functions which "operate" on a HAL device itself.\nOperators are akin to "public methods" in object oriented-languages.'),(0,i.kt)("p",null,"For more information about operators, see ",(0,i.kt)("a",{parentName:"p",href:"/vizn3d_smartlock_oobe/docs/framework/hal_devices/overview#Operators"},"Operators"),"."),(0,i.kt)("h3",{id:"init"},"Init"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"sln_flash_status_t (*init)(const flash_dev_t *dev);\n")),(0,i.kt)("p",null,"Initialize the flash & filesystem."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Init")," should initialize any hardware resources required by the flash device (pins, ports, clock, etc).",(0,i.kt)("sup",{parentName:"p",id:"fnref-2"},(0,i.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2")),"\nIn addition to initializing the hardware,\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"init")," function should also mount the filesystem.",(0,i.kt)("sup",{parentName:"p",id:"fnref-3"},(0,i.kt)("a",{parentName:"sup",href:"#fn-3",className:"footnote-ref"},"3"))),(0,i.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},(0,i.kt)("sup",{parentName:"p",id:"fnref-2"},(0,i.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2"))," An application that runs from flash (does XiP) should not initialize/deinitialize any hardware.\nIf a hardware change is truly needed,\nthe change should be performed with caution."))),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},(0,i.kt)("sup",{parentName:"p",id:"fnref-3"},(0,i.kt)("a",{parentName:"sup",href:"#fn-3",className:"footnote-ref"},"3"))," Some lightweight FS may not require mounting and can be prebuilt/preloaded on the flash instead.\nRegardless,\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"init")," function should result in the filesystem being in a usable state."))),(0,i.kt)("h3",{id:"deinit"},"Deinit"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"hal_lpm_status_t (*deinit)(const lpm_dev_t *dev);\n")),(0,i.kt)("p",null,'"Deinitialize" the flash & filesystem.'),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"DeInit")," should release any hardware resources a flash device might use (I/O ports, IRQs, etc.), turn off the hardware, and perform any other shutdown the device requires.",(0,i.kt)("sup",{parentName:"p",id:"fnref-2"},(0,i.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2"))),(0,i.kt)("h3",{id:"format"},"Format"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"sln_flash_status_t (*format)(const flash_dev_t *dev);\n")),(0,i.kt)("p",null,"Clean and format the filesystem."),(0,i.kt)("h3",{id:"save"},"Save"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"sln_flash_status_t (*save)(const flash_dev_t *dev, const char *path, void *buf, unsigned int size);\n")),(0,i.kt)("p",null,"Save a file with the contents of ",(0,i.kt)("inlineCode",{parentName:"p"},"buf")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"path")," in the filesystem."),(0,i.kt)("h3",{id:"append"},"Append"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"sln_flash_status_t (*append)(const flash_dev_t *dev, const char *path, void *buf, unsigned int size, bool overwrite);\n")),(0,i.kt)("p",null,"Append the contents of ",(0,i.kt)("inlineCode",{parentName:"p"},"buf")," to an existing file located at ",(0,i.kt)("inlineCode",{parentName:"p"},"path"),"."),(0,i.kt)("p",null,"Setting ",(0,i.kt)("inlineCode",{parentName:"p"},"overwrite")," equal to true will cause append from the beginning of the file instead.",(0,i.kt)("sup",{parentName:"p",id:"fnref-4"},(0,i.kt)("a",{parentName:"sup",href:"#fn-4",className:"footnote-ref"},"4"))),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},(0,i.kt)("sup",{parentName:"p",id:"fnref-4"},(0,i.kt)("a",{parentName:"sup",href:"#fn-4",className:"footnote-ref"},"4"))," ",(0,i.kt)("inlineCode",{parentName:"p"},"overwrite == true")," makes this function nearly equivalent to the save function,\nthe only difference being that this will not create a new file."))),(0,i.kt)("h3",{id:"read"},"Read"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"sln_flash_status_t (*read)(const flash_dev_t *dev, const char *path, void *buf, unsigned int size);\n")),(0,i.kt)("p",null,"Read a file from the filesystem located at ",(0,i.kt)("inlineCode",{parentName:"p"},"path")," and store the contents in ",(0,i.kt)("inlineCode",{parentName:"p"},"buf"),".",(0,i.kt)("sup",{parentName:"p",id:"fnref-5"},(0,i.kt)("a",{parentName:"sup",href:"#fn-5",className:"footnote-ref"},"5"))),(0,i.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},(0,i.kt)("sup",{parentName:"p",id:"fnref-5"},(0,i.kt)("a",{parentName:"sup",href:"#fn-5",className:"footnote-ref"},"5"))," It is up to the user to guarantee that the buffer supplied will fit the contents of the file being read."))),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"For now,\nthe current functionality of ",(0,i.kt)("inlineCode",{parentName:"p"},"read")," is limited.\nIn the future we plan to extend this function to support offset read,\nfile physical address,\ntrue length return,\nand more."))),(0,i.kt)("h3",{id:"make-directory"},"Make Directory"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"sln_flash_status_t (*mkdir)(const flash_dev_t *dev, const char *path);\n")),(0,i.kt)("p",null,"Create a directory located at ",(0,i.kt)("inlineCode",{parentName:"p"},"path"),"."),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"If the filesystem in use does not support directories,\nthis operator can be set to ",(0,i.kt)("inlineCode",{parentName:"p"},"NULL"),"."))),(0,i.kt)("h3",{id:"remove"},"Remove"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"sln_flash_status_t (*rm)(const flash_dev_t *dev, const char *path);\n")),(0,i.kt)("p",null,"Remove the file located at ",(0,i.kt)("inlineCode",{parentName:"p"},"path"),"."),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"If the filesystem in use does not support directories,\nthis operator can be set to ",(0,i.kt)("inlineCode",{parentName:"p"},"NULL"),"."))),(0,i.kt)("h3",{id:"rename"},"Rename"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"sln_flash_status_t (*rename)(const flash_dev_t *dev, const char *oldPath, const char *newPath);\n")),(0,i.kt)("p",null,"Rename/move a file from ",(0,i.kt)("inlineCode",{parentName:"p"},"oldPath")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"newPath"),"."),(0,i.kt)("h3",{id:"cleanup"},"Cleanup"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"sln_flash_status_t (*cleanup)(const flash_dev_t *dev, unsigned int timeout_ms);\n")),(0,i.kt)("p",null,"Clean up the filesystem."),(0,i.kt)("p",null,'This function is used to help minimize delays introduced by things like fragmentation caused during "erase sector" operations\nwhich can lead to unwanted delays when searching for the next available sector.'),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"timeout_ms")," specifies how much time to wait before performing another cleanup.\nThis helps prevent against multiple HAL devices calling ",(0,i.kt)("inlineCode",{parentName:"p"},"cleanup")," and stalling the filesystem."),(0,i.kt)("h2",{id:"example"},"Example"),(0,i.kt)("p",null,"Because only one flash device can be registered at a time per the design of the framework,\nthe SLN-VIZN3D-IOT Smart Lock project has only one filesystem implemented."),(0,i.kt)("p",null,"The source file for this flash HAL device can be found at ",(0,i.kt)("inlineCode",{parentName:"p"},"HAL/common/hal_flash_littlefs.c"),"."),(0,i.kt)("p",null,"In this example,\nwe will demonstrate a way to integrate the well known ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/littlefs-project/littlefs"},"Littlefs")," in our framework."),(0,i.kt)("p",null,"Littlefs is a lightweight file-system that is designed to handle random power failures.\nThe architecture of the file-system allows having directories and files.\nAs a result, this example uses the following file layout:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash",metastring:'title="Littlefs file layout"',title:'"Littlefs',file:!0,'layout"':!0},"root-directory\n\u251c\u2500\u2500 cfg\n\u2502   \u251c\u2500\u2500 Metadata\n\u2502   \u251c\u2500\u2500 fwk_cfg - stores framework related information.\n\u2502   \u2514\u2500\u2500 app_cfg - stores app specific information.\n\u251c\u2500\u2500 oasis\n\u2502   \u251c\u2500\u2500 Metadata\n\u2502   \u2514\u2500\u2500 faceFiles - the number of files that stores faces are up to 100\n\u2514\u2500\u2500 wifi_info\n    \u251c\u2500\u2500 wifi_info\n    \u2514\u2500\u2500 ftp_info\n")),(0,i.kt)("h3",{id:"littlefs-device"},"Littlefs Device"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="HAL/common/hal_flash_littlefs.c"',title:'"HAL/common/hal_flash_littlefs.c"'},'static sln_flash_status_t _lfs_init()\n{\n    int res = kStatus_HAL_FlashSuccess;\n    if (s_LittlefsHandler.lfsMounted)\n    {\n        return kStatus_HAL_FlashSuccess;\n    }\n    s_LittlefsHandler.lock = xSemaphoreCreateMutex();\n    if (s_LittlefsHandler.lock == NULL)\n    {\n        LOGE("Littlefs create lock failed");\n        return kStatus_HAL_FlashFail;\n    }\n\n    _lfs_get_default_config(&s_LittlefsHandler.cfg);\n#if DEBUG\n    BOARD_InitFlashResources();\n#endif\n    SLN_Flash_Init();\n    if (res)\n    {\n        LOGE("Littlefs storage init failed: %i", res);\n        return kStatus_HAL_FlashFail;\n    }\n\n    res = lfs_mount(&s_LittlefsHandler.lfs, &s_LittlefsHandler.cfg);\n    if (res == 0)\n    {\n        s_LittlefsHandler.lfsMounted = 1;\n        LOGD("Littlefs mount success");\n    }\n    else if (res == LFS_ERR_CORRUPT)\n    {\n        LOGE("Littlefs corrupt");\n        lfs_format(&s_LittlefsHandler.lfs, &s_LittlefsHandler.cfg);\n        LOGD("Littlefs attempting to mount after reformatting...");\n        res = lfs_mount(&s_LittlefsHandler.lfs, &s_LittlefsHandler.cfg);\n        if (res == 0)\n        {\n            s_LittlefsHandler.lfsMounted = 1;\n            LOGD("Littlefs mount success");\n        }\n        else\n        {\n            LOGE("Littlefs mount failed again");\n            return kStatus_HAL_FlashFail;\n        }\n    }\n    else\n    {\n        LOGE("Littlefs error while mounting");\n    }\n\n    return res;\n}\n\nstatic sln_flash_status_t _lfs_cleanupHandler(const flash_dev_t *dev,\n                                                             unsigned int timeout_ms)\n{\n    sln_flash_status_t status              = kStatus_HAL_FlashSuccess;\n    uint32_t usedBlocks[LFS_SECTORS/32]    = {0};\n    uint32_t emptyBlocks                   = 0;\n    uint32_t startTime                     = 0;\n    uint32_t currentTime                   = 0;\n\n    if (_lock())\n    {\n        LOGE("Littlefs _lock failed");\n        return kStatus_HAL_FlashFail;\n    }\n\n    /* create used block list */\n    lfs_fs_traverse(&s_LittlefsHandler.lfs, _lfs_traverse_create_used_blocks,\n                                 &usedBlocks);\n\n    startTime = sln_current_time_us();\n\n    /* find next block starting from free.i */\n    for (int i = 0; i < LFS_SECTORS; i++)\n    {\n        currentTime = sln_current_time_us();\n        /* Check timeout */\n        if ((timeout_ms) && (currentTime >= (startTime + timeout_ms * 1000)))\n        {\n            break;\n        }\n\n        lfs_block_t block = (s_LittlefsHandler.lfs.free.i + i) % LFS_SECTORS;\n\n        /* take next unused marked block */\n        if (!_is_blockBitSet(usedBlocks, block))\n        {\n            /* If the block is marked as free but not yet erased, try to erase it */\n            LOGD("Block %i is unused, try to erase it", block);\n            _lfs_qspiflash_erase(&s_LittlefsConfigDefault, block);\n            emptyBlocks += 1;\n        }\n    }\n\n    LOGI("%i empty_blocks starting from %i available in %ims",\n                 emptyBlocks, s_LittlefsHandler.lfs.free.i, (sln_current_time_us() - startTime)/1000);\n\n    _unlock();\n    return status;\n}\n\nstatic sln_flash_status_t _lfs_formatHandler(const flash_dev_t *dev)\n{\n    if (_lock())\n    {\n        LOGE("Littlefs _lock failed");\n        return kStatus_HAL_FlashFail;\n    }\n    lfs_format(&s_LittlefsHandler.lfs, &s_LittlefsHandler.cfg);\n    _unlock();\n    return kStatus_HAL_FlashSuccess;\n}\n\nstatic sln_flash_status_t _lfs_rmHandler(const flash_dev_t *dev, const char *path)\n{\n    int res;\n\n    if (_lock())\n    {\n        LOGE("Littlefs _lock failed");\n        return kStatus_HAL_FlashFail;\n    }\n\n    res = lfs_remove(&s_LittlefsHandler.lfs, path);\n    if (res)\n    {\n        LOGE("Littlefs while removing: %i", res);\n        _unlock();\n        if (res == LFS_ERR_NOENT)\n        {\n            return kStatus_HAL_FlashFileNotExist;\n        }\n\n        return kStatus_HAL_FlashFail;\n    }\n    _unlock();\n    return kStatus_HAL_FlashSuccess;\n}\n\nstatic sln_flash_status_t _lfs_mkdirHandler(const flash_dev_t *dev, const char *path)\n{\n    int res;\n\n    if (_lock())\n    {\n        LOGE("Littlefs _lock failed");\n        return kStatus_HAL_FlashFail;\n    }\n\n    res = lfs_mkdir(&s_LittlefsHandler.lfs, path);\n\n    if (res == LFS_ERR_EXIST)\n    {\n        LOGD("Littlefs directory exists: %i", res);\n        _unlock();\n        return kStatus_HAL_FlashDirExist;\n    }\n    else if (res)\n    {\n        LOGE("Littlefs creating directory: %i", res);\n        _unlock();\n        return kStatus_HAL_FlashFail;\n    }\n    _unlock();\n    return kStatus_HAL_FlashSuccess;\n}\n\nstatic sln_flash_status_t _lfs_writeHandler(const flash_dev_t *dev, const char *path, void *buf, unsigned int size)\n{\n    int res;\n    lfs_file_t file;\n\n    if (_lock())\n    {\n        LOGE("Littlefs _lock failed");\n        return kStatus_HAL_FlashFail;\n    }\n\n    res = lfs_file_opencfg(&s_LittlefsHandler.lfs, &file, path, LFS_O_CREAT, &s_FileDefault);\n    if (res)\n    {\n        LOGE("Littlefs opening file: %i", res);\n        _unlock();\n        return kStatus_HAL_FlashFail;\n    }\n\n    res = lfs_file_write(&s_LittlefsHandler.lfs, &file, buf, size);\n    if (res < 0)\n    {\n        LOGE("Littlefs writing file: %i", res);\n        _unlock();\n        return kStatus_HAL_FlashFail;\n    }\n\n    res = lfs_file_close(&s_LittlefsHandler.lfs, &file);\n    if (res)\n    {\n        LOGE("Littlefs closing file: %i", res);\n        _unlock();\n        return kStatus_HAL_FlashFail;\n    }\n\n    _unlock();\n    return kStatus_HAL_FlashSuccess;\n}\n\nstatic sln_flash_status_t _lfs_appendHandler(const flash_dev_t *dev,\n                                                            const char *path,\n                                                            void *buf,\n                                                            unsigned int size,\n                                                            bool overwrite)\n{\n    int res;\n    lfs_file_t file;\n\n    if (_lock())\n    {\n        LOGE("Littlefs _lock failed");\n        return kStatus_HAL_FlashFail;\n    }\n\n    res = lfs_file_opencfg(&s_LittlefsHandler.lfs, &file, path, LFS_O_APPEND, &s_FileDefault);\n    if (res)\n    {\n        LOGE("Littlefs opening file: %i", res);\n        _unlock();\n        if (res == LFS_ERR_NOENT)\n        {\n            return kStatus_HAL_FlashFileNotExist;\n        }\n        return kStatus_HAL_FlashFail;\n    }\n\n    if (overwrite == true)\n    {\n        res = lfs_file_truncate(&s_LittlefsHandler.lfs, &file, 0);\n\n        if (res < 0)\n        {\n            LOGE("Littlefs truncate file: %i", res);\n            _unlock();\n            return kStatus_HAL_FlashFail;\n        }\n    }\n\n    res = lfs_file_write(&s_LittlefsHandler.lfs, &file, buf, size);\n    if (res < 0)\n    {\n        LOGE("Littlefs writing file: %i", res);\n        _unlock();\n        return kStatus_HAL_FlashFail;\n    }\n\n    res = lfs_file_close(&s_LittlefsHandler.lfs, &file);\n    if (res)\n    {\n        LOGE("Littlefs closing file: %i", res);\n        _unlock();\n        return kStatus_HAL_FlashFail;\n    }\n\n    _unlock();\n    return kStatus_HAL_FlashSuccess;\n}\n\nstatic sln_flash_status_t _lfs_readHandler(const flash_dev_t *dev, const char *path, void *buf, unsigned int size)\n{\n    int res;\n    int offset = 0;\n    lfs_file_t file;\n\n    if (_lock())\n    {\n        LOGE("Littlefs _lock failed");\n        return kStatus_HAL_FlashFail;\n    }\n    res = lfs_file_opencfg(&s_LittlefsHandler.lfs, &file, path, LFS_O_RDONLY, &s_FileDefault);\n    if (res)\n    {\n        LOGE("Littlefs opening file: %i", res);\n        _unlock();\n        if (res == LFS_ERR_NOENT)\n        {\n            return kStatus_HAL_FlashFileNotExist;\n        }\n        return kStatus_HAL_FlashFail;\n    }\n\n    do\n    {\n        res = lfs_file_read(&s_LittlefsHandler.lfs, &file, (buf + offset), size);\n        if (res < 0)\n        {\n            LOGE("Littlefs reading file: %i", res);\n            _unlock();\n            return kStatus_HAL_FlashFail;\n        }\n        else if (res == 0)\n        {\n            LOGD("Littlefs reading file \\"%s\\": Read only %d. %d bytes not found ", path, offset, size);\n            break;\n        }\n\n        offset += res;\n        size -= res;\n    } while (size > 0);\n\n    res = lfs_file_close(&s_LittlefsHandler.lfs, &file);\n    if (res)\n    {\n        LOGE("Littlefs closing file: %i", res);\n        _unlock();\n        return kStatus_HAL_FlashFail;\n    }\n\n    _unlock();\n    return kStatus_HAL_FlashSuccess;\n}\n\nstatic sln_flash_status_t _lfs_renameHandler(const flash_dev_t *dev, const char *OldPath, const char *NewPath)\n{\n    int res;\n\n    if (_lock())\n    {\n        LOGE("Littlefs _lock failed");\n        return kStatus_HAL_FlashFail;\n    }\n\n    res = lfs_rename(&s_LittlefsHandler.lfs, OldPath, NewPath);\n    if (res)\n    {\n        LOGE("Littlefs renaming file: %i", res);\n        _unlock();\n        return kStatus_HAL_FlashFail;\n    }\n    _unlock();\n    return kStatus_HAL_FlashSuccess;\n}\n\nconst static flash_dev_operator_t s_FlashDev_LittlefsOps = {\n    .init   = _lfs_init,\n    .deinit = NULL,\n    .format = _lfs_formatHandler,\n    .append = _lfs_appendHandler,\n    .save   = _lfs_writeHandler,\n    .read   = _lfs_readHandler,\n    .mkdir  = _lfs_mkdirHandler,\n    .rm     = _lfs_rmHandler,\n    .rename = _lfs_renameHandler,\n    .cleanup= _lfs_cleanupHandler,\n};\n\nstatic flash_dev_t s_FlashDev_Littlefs = {\n    .id  = 0,\n    .ops = &s_FlashDev_LittlefsOps,\n};\n\nint HAL_FlashDev_Littlefs_Init()\n{\n    int error = 0;\n    LOGD("++HAL_FlashDev_Littlefs_Init");\n    _lfs_init();\n\n    LOGD("--HAL_FlashDev_Littlefs_Init");\n    error = FWK_Flash_DeviceRegister(&s_FlashDev_Littlefs);\n\n    FWK_LpmManager_RegisterRequestHandler(&s_LpmReq);\n    return error;\n}\n')),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"What was presented here shows only the operators described above.\nFor more information regarding Littlefs configuration,\nFlexSPI configuration, optimization done.\nDon't forget to check the full code base."))))}p.isMDXComponent=!0}}]);