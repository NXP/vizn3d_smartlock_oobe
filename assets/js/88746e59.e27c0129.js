"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[928],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return u}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,p=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=s(n),u=a,_=d["".concat(p,".").concat(u)]||d[u]||m[u]||l;return n?r.createElement(_,i(i({ref:t},c),{},{components:n})):r.createElement(_,i({ref:t},c))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,i=new Array(l);i[0]=d;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var s=2;s<l;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8541:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return p},metadata:function(){return s},toc:function(){return c},default:function(){return d}});var r=n(7462),a=n(3366),l=(n(7294),n(3905)),i=["components"],o={sidebar_position:7},p="Low Power Devices",s={unversionedId:"framework/hal_devices/low_power",id:"framework/hal_devices/low_power",isDocsHomePage:!1,title:"Low Power Devices",description:"The Low Power/LPM HAL device represents an abstraction used to implement a device which controls the power management of the device by configuring the chip-level power mode (normal operation, SNVS, etc.).",source:"@site/docs/framework/hal_devices/low_power.md",sourceDirName:"framework/hal_devices",slug:"/framework/hal_devices/low_power",permalink:"/vizn3d_smartlock_oobe/docs/framework/hal_devices/low_power",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"VAlgo Devices",permalink:"/vizn3d_smartlock_oobe/docs/framework/hal_devices/valgo"},next:{title:"Flash Devices",permalink:"/vizn3d_smartlock_oobe/docs/framework/hal_devices/flash"}},c=[{value:"Device Definition",id:"device-definition",children:[],level:2},{value:"Operators",id:"operators",children:[{value:"Init",id:"init",children:[],level:3},{value:"Deinit",id:"deinit",children:[],level:3},{value:"OpenTimer",id:"opentimer",children:[],level:3},{value:"StopTimer",id:"stoptimer",children:[],level:3},{value:"OpenPreEnterTimer",id:"openpreentertimer",children:[],level:3},{value:"StopPreEnterTimer",id:"stoppreentertimer",children:[],level:3},{value:"EnterSleep",id:"entersleep",children:[],level:3},{value:"Lock",id:"lock",children:[],level:3},{value:"Unlock",id:"unlock",children:[],level:3}],level:2},{value:"Components",id:"components",children:[{value:"timer",id:"timer",children:[],level:3},{value:"preEnterSleepTimer",id:"preentersleeptimer",children:[],level:3},{value:"lock",id:"lock-1",children:[],level:3},{value:"callback",id:"callback",children:[],level:3},{value:"PreEnterSleepCallback",id:"preentersleepcallback",children:[],level:3}],level:2},{value:"Example",id:"example",children:[{value:"LPM Manager Device",id:"lpm-manager-device",children:[],level:3},{value:"Requesting Device",id:"requesting-device",children:[],level:3}],level:2}],m={toc:c};function d(e){var t=e.components,n=(0,a.Z)(e,i);return(0,l.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"low-power-devices"},"Low Power Devices"),(0,l.kt)("p",null,"The Low Power/",(0,l.kt)("inlineCode",{parentName:"p"},"LPM")," HAL device represents an abstraction used to implement a device which controls the power management of the device by configuring the chip-level power mode (normal operation, SNVS, etc.)."),(0,l.kt)("p",null,"Unlike other devices which may represent a real, physical device, the low power HAL device is purely a \"virtual\" abstraction mechanism representing the chip's power regulation controls.\nAs a result,\nthe low power HAL device is platform-dependent\nbecause it relies on the different power modes and configuration options made available by the platform being used.\nAdditionally,\nonly one low power HAL device can (and is necessary to) be registered at a time\nbecause a chip's power regulatory functionality will not typically require multiple disparate components.\nThis means that the API calls to the ",(0,l.kt)("a",{parentName:"p",href:"/vizn3d_smartlock_oobe/docs/framework/device_managers/lpm_manager#APIs"},"Low Power Manager")," are\nessentially wrappers over the single LPM device's ",(0,l.kt)("a",{parentName:"p",href:"#operators"},"operators"),"."),(0,l.kt)("p",null,"As for functionality,\nthe low power HAL device provides:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Multi-level low-power switching"),(0,l.kt)("li",{parentName:"ul"},"Manual power state configuration"),(0,l.kt)("li",{parentName:"ul"},"Automatic power state configuration via periodic idle checks and other flags")),(0,l.kt)("p",null,'The low power mode device also provides an exit mechanism which is called before entering low power mode,\nto ensure components are properly shut down before sleeping.\nThis is achieved by using a series of timers,\none as a periodic idle check to wait for a specified timeout period before shutting down,\nand the other as an "exit timer" which reserves a sufficient amount of time for other HAL devices to properly shutdown.'),(0,l.kt)("h2",{id:"device-definition"},"Device Definition"),(0,l.kt)("p",null,"The HAL device definition for LPM devices can be found under ",(0,l.kt)("inlineCode",{parentName:"p"},"framework/hal_api/hal_lpm_dev.h")," and is reproduced below:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="framework/hal_api/hal_lpm_dev.h"',title:'"framework/hal_api/hal_lpm_dev.h"'},"/*! @brief Attributes of a lpm device */\nstruct _lpm_dev\n{\n    /* unique id which is assigned by lpm manager during the registration */\n    int id;\n    /* operations */\n    const lpm_dev_operator_t *ops;\n    /* timer */\n    TimerHandle_t timer;\n    /* pre-enter sleep timer */\n    TimerHandle_t preEnterSleepTimer;\n    /* lock */\n    SemaphoreHandle_t lock;\n    /* callback */\n    lpm_manager_timer_callback_t callback;\n    /* preEnterSleepCallback */\n    lpm_manager_timer_callback_t preEnterSleepCallback;\n};\n")),(0,l.kt)("p",null,"The device ",(0,l.kt)("a",{parentName:"p",href:"#operators"},"operators")," associated with LPM HAL devices are as shown below:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"/*! @brief Callback function to timeout check requester list busy status. */\ntypedef int (*lpm_manager_timer_callback_t)(lpm_dev_t *dev);\n\n/*! @brief Operation that needs to be implemented by a lpm device */\ntypedef struct _lpm_dev_operator\n{\n    hal_lpm_status_t (*init)(lpm_dev_t *dev,\n                             lpm_manager_timer_callback_t callback,\n                             lpm_manager_timer_callback_t preEnterSleepTimer);\n    hal_lpm_status_t (*deinit)(const lpm_dev_t *dev);\n    hal_lpm_status_t (*openTimer)(const lpm_dev_t *dev);\n    hal_lpm_status_t (*stopTimer)(const lpm_dev_t *dev);\n    hal_lpm_status_t (*openPreEnterTimer)(const lpm_dev_t *dev);\n    hal_lpm_status_t (*stopPreEnterTimer)(const lpm_dev_t *dev);\n    hal_lpm_status_t (*enterSleep)(const lpm_dev_t *dev, hal_lpm_mode_t mode);\n    hal_lpm_status_t (*lock)(const lpm_dev_t *dev);\n    hal_lpm_status_t (*unlock)(const lpm_dev_t *dev);\n} lpm_dev_operator_t;\n\ntypedef struct _hal_lpm_request\n{\n    void *dev;                              /* request dev handle */\n    char name[LPM_REQUEST_NAME_MAX_LENGTH]; /* request name */\n} hal_lpm_request_t;\n")),(0,l.kt)("h2",{id:"operators"},"Operators"),(0,l.kt)("p",null,'Operators are functions which "operate" on a HAL device itself.\nOperators are akin to "public methods" in object oriented-languages,\nand are used by the Low Power Manager to setup, start, etc. its registered low power device.'),(0,l.kt)("p",null,"For more information about operators, see ",(0,l.kt)("a",{parentName:"p",href:"/vizn3d_smartlock_oobe/docs/framework/hal_devices/overview#Operators"},"Operators"),"."),(0,l.kt)("h3",{id:"init"},"Init"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"hal_lpm_status_t (*init)(lpm_dev_t *dev, lpm_manager_timer_callback_t callback,\n                                         lpm_manager_timer_callback_t preEnterSleepTimer);\n")),(0,l.kt)("p",null,"Initialize the lpm device."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Init")," should initialize any hardware resources the lpm device requires (I/O ports, IRQs, etc.), turn on the hardware, and perform any other setup the device requires."),(0,l.kt)("p",null,"The ",(0,l.kt)("a",{parentName:"p",href:"#callback"},"callback function")," to the device's manager is typically installed as part of the ",(0,l.kt)("inlineCode",{parentName:"p"},"Init")," function as well."),(0,l.kt)("p",null,"This operator will be called by the Input Manager when the Input Manager task first starts."),(0,l.kt)("h3",{id:"deinit"},"Deinit"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"hal_lpm_status_t (*deinit)(const lpm_dev_t *dev);\n")),(0,l.kt)("p",null,'"Deinitialize" the lpm device.'),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"DeInit")," should release any hardware resources the lpm device uses (I/O ports, IRQs, etc.), turn off the hardware, and perform any other shutdown the device requires."),(0,l.kt)("p",null,"This operator will be called by the Input Manager when the Input Manager task ends",(0,l.kt)("sup",{parentName:"p",id:"fnref-1"},(0,l.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),"."),(0,l.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},(0,l.kt)("sup",{parentName:"p",id:"fnref-1"},(0,l.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),"The ",(0,l.kt)("inlineCode",{parentName:"p"},"DeInit")," function generally will not be called under normal operation."))),(0,l.kt)("h3",{id:"opentimer"},"OpenTimer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"hal_lpm_status_t (*openTimer)(const lpm_dev_t *dev);\n")),(0,l.kt)("p",null,"Kicks off the periodic idle check timer."),(0,l.kt)("h3",{id:"stoptimer"},"StopTimer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"hal_lpm_status_t (*stopTimer)(const lpm_dev_t *dev);\n")),(0,l.kt)("p",null,"Stops the periodic idle check timer."),(0,l.kt)("p",null,"After all busy requests (BLE connection established, face registration in progress) have ceased,\nthis function will be called and begin the shutdown process for other HAL devices."),(0,l.kt)("h3",{id:"openpreentertimer"},"OpenPreEnterTimer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"hal_lpm_status_t (*openPreEnterTimer)(const lpm_dev_t *dev);\n")),(0,l.kt)("p",null,"Kicks off the ",(0,l.kt)("inlineCode",{parentName:"p"},"preEnterSleepTimer"),"."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"preEnterSleepTimer")," is used to provide other HAL devices sufficient time to properly shutdown before the board enters sleep mode.\nThis function will be called after the periodic idle check timer has stopped (due to a timeout)."),(0,l.kt)("h3",{id:"stoppreentertimer"},"StopPreEnterTimer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"hal_lpm_status_t (*stopPreEnterTimer)(const lpm_dev_t *dev);\n")),(0,l.kt)("p",null,"Stops the ",(0,l.kt)("inlineCode",{parentName:"p"},"preEnterSleepTimer"),"."),(0,l.kt)("p",null,"This function is called to stop the timer associated with the pre-sleep shutdown process.\nAfter this timer ends,\nthe ",(0,l.kt)("a",{parentName:"p",href:"#entersleep"},(0,l.kt)("inlineCode",{parentName:"a"},"EnterSleep"))," function will be called and the device will power down."),(0,l.kt)("h3",{id:"entersleep"},"EnterSleep"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"hal_lpm_status_t (*enterSleep)(const lpm_dev_t *dev, hal_lpm_mode_t mode);\n")),(0,l.kt)("p",null,"Enter sleep mode using the low power mode specified in the function call",(0,l.kt)("sup",{parentName:"p",id:"fnref-2"},(0,l.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2")),"."),(0,l.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},(0,l.kt)("sup",{parentName:"p",id:"fnref-2"},(0,l.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2"))," The power modes available vary based on the platform in use."))),(0,l.kt)("h3",{id:"lock"},"Lock"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"hal_lpm_status_t (*lock)(const lpm_dev_t *dev);\n")),(0,l.kt)("p",null,"Acquire the lock for the low power device."),(0,l.kt)("p",null,"The low power manager uses a lock-based system to prevent accidentally entering sleep mode before all devices are ready to enter sleep.\nThe ",(0,l.kt)("inlineCode",{parentName:"p"},"Lock")," function is called by the Low Power manager in response to a HAL device signaling that it is performing a critical function which requires that the board does not enter sleep until complete."),(0,l.kt)("h3",{id:"unlock"},"Unlock"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"hal_lpm_status_t (*unlock)(const lpm_dev_t *dev);\n")),(0,l.kt)("p",null,"Release the lock for the low power device."),(0,l.kt)("p",null,"The low power manager uses a lock-based system to prevent accidentally entering sleep mode before all devices are ready to enter sleep.\nThe ",(0,l.kt)("inlineCode",{parentName:"p"},"Unlock")," function is called by the Low Power manager in response to a HAL device signaling that it is finished performing a critical function which required that the board did not enter sleep until it was completed."),(0,l.kt)("h2",{id:"components"},"Components"),(0,l.kt)("h3",{id:"timer"},"timer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"/* timer */\nTimerHandle_t timer;\n")),(0,l.kt)("p",null,"This timer is use to periodically check busy requests from other HAL devices."),(0,l.kt)("h3",{id:"preentersleeptimer"},"preEnterSleepTimer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"/* pre-enter sleep timer */\nTimerHandle_t preEnterSleepTimer;\n")),(0,l.kt)("p",null,"This timer is used to provide a sufficient amount of time for HAL devices to shutdown prior to entering sleep mode."),(0,l.kt)("h3",{id:"lock-1"},"lock"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"/* lock */\nSemaphoreHandle_t lock;\n")),(0,l.kt)("p",null,"This lock is used to maintain thread safety when multiple task need to call the Low Power Manager,\nand is managed by the Low Power Manager."),(0,l.kt)("h3",{id:"callback"},"callback"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"/* callback */\nlpm_manager_timer_callback_t callback;\n")),(0,l.kt)("p",null,"Callback to the Low Power Manager.\nThe HAL device invokes this callback to notify the vision algorithm manager of specific events."),(0,l.kt)("p",null,"The Low Power Manager will provide this callback to the device when the ",(0,l.kt)("inlineCode",{parentName:"p"},"init")," operator is called.\nAs a result, the HAL device should make sure to store the callback in the ",(0,l.kt)("inlineCode",{parentName:"p"},"init")," operator's implementation."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="HAL/common/hal_sln_lpm.c" {10}',title:'"HAL/common/hal_sln_lpm.c"',"{10}":!0},"hal_lpm_status_t HAL_LpmDev_Init(lpm_dev_t *dev,\n                                lpm_manager_timer_callback_t callback,\n                                lpm_manager_timer_callback_t preEnterSleepCallback)\n{\n    int ret = kStatus_HAL_LpmSuccess;\n\n    dev->callback              = callback;\n    dev->preEnterSleepCallback = preEnterSleepCallback;\n")),(0,l.kt)("h3",{id:"preentersleepcallback"},"PreEnterSleepCallback"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"/* preEnterSleepCallback */\nlpm_manager_timer_callback_t preEnterSleepCallback;\n")),(0,l.kt)("p",null,'Callback function which is called after the "preEnterSleep" timer terminates.'),(0,l.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"This callback comes from the LPM Manager"))),(0,l.kt)("h2",{id:"example"},"Example"),(0,l.kt)("p",null,"Because only one low power device can be registered at a time per the design of the framework,\nthe SLN-VIZN3D-IOT Smart Lock project has only one low power device implemented."),(0,l.kt)("p",null,"The source file for this low power device can be found at ",(0,l.kt)("inlineCode",{parentName:"p"},"HAL/common/hal_sln_lpm.c"),"."),(0,l.kt)("p",null,"In this example,\nwe will demonstrate the use of a low power device (using FreeRTOS for timers, etc.)\nin conjunction with a device/manager of a different type."),(0,l.kt)("p",null,"The ",(0,l.kt)("a",{parentName:"p",href:"#lpm-manager-device"},"LPM Manager Device")," implements all the power switching functionality we need,\nwhile the ",(0,l.kt)("a",{parentName:"p",href:"#other-manager-device"},"secondary device/manager")," will attempt to make busy requests (lock the LPM device)\nand enable/disable low power mode."),(0,l.kt)("h3",{id:"lpm-manager-device"},"LPM Manager Device"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="HAL/common/hal_sln_lpm.c"',title:'"HAL/common/hal_sln_lpm.c"'},'/* Here call periodic callback to check idle status. */\nstatic void HAL_LpmDev_TimerCallback(TimerHandle_t handle)\n{\n    if (handle == NULL)\n    {\n        return;\n    }\n\n    lpm_dev_t *pDev = (lpm_dev_t *)pvTimerGetTimerID(handle);\n    if (pDev->callback != NULL)\n    {\n        pDev->callback(pDev);\n    }\n}\n\n/* Here call preEnterSleepCallback. Duing this time, all device have already exit. So this callback will call enterSleep operator to enter low power mode. */\nstatic void HAL_LpmDev_PreEnterSleepTimerCallback(TimerHandle_t handle)\n{\n    if (handle == NULL)\n    {\n        return;\n    }\n\n    lpm_dev_t *pDev = (lpm_dev_t *)pvTimerGetTimerID(handle);\n    if (pDev->preEnterSleepCallback != NULL)\n    {\n        pDev->preEnterSleepCallback(pDev);\n    }\n}\n\nhal_lpm_status_t HAL_LpmDev_Init(lpm_dev_t *dev,\n                                lpm_manager_timer_callback_t callback,\n                                lpm_manager_timer_callback_t preEnterSleepCallback)\n{\n    int ret = kStatus_HAL_LpmSuccess;\n\n    dev->callback              = callback;\n    dev->preEnterSleepCallback = preEnterSleepCallback;\n\n    /* put low power hardware init here */\n\n    /* put periodic timer create and init here */\n    dev->timer = xTimerCreate("LpmTimer", pdMS_TO_TICKS(1000), pdTRUE, (void *)dev, HAL_LpmDev_TimerCallback);\n    if (dev->timer == NULL)\n    {\n        return kStatus_HAL_LpmTimerNull;\n    }\n\n    /* put exit timer create and init here */\n    dev->preEnterSleepTimer = xTimerCreate("LpmPreEnterSleepTimer", pdMS_TO_TICKS(1500), pdTRUE, (void *)dev,\n                                           HAL_LpmDev_PreEnterSleepTimerCallback);\n    if (dev->preEnterSleepTimer == NULL)\n    {\n        return kStatus_HAL_LpmTimerNull;\n    }\n\n    /* put lock create and init here */\n    dev->lock = xSemaphoreCreateMutex();\n    if (dev->lock == NULL)\n    {\n        return kStatus_HAL_LpmLockNull;\n    }\n\n    /* put init low power mode and status here, detial can find in lpm_manager. */\n    FWK_LpmManager_SetSleepMode(kLPMMode_SNVS);\n    FWK_LpmManager_EnableSleepMode(kLPMManagerStatus_SleepDisable);\n\n    return ret;\n}\n\nhal_lpm_status_t HAL_LpmDev_Deinit(const lpm_dev_t *dev)\n{\n    int ret = kStatus_HAL_LpmSuccess;\n\n    return ret;\n}\n\nhal_lpm_status_t HAL_LpmDev_OpenTimer(const lpm_dev_t *dev)\n{\n    int ret = kStatus_HAL_LpmSuccess;\n\n    if (dev->timer == NULL)\n    {\n        return kStatus_HAL_LpmTimerNull;\n    }\n\n    if (xTimerStart(dev->timer, 0) != pdPASS)\n    {\n        ret = kStatus_HAL_LpmTimerFail;\n    }\n\n    return ret;\n}\n\nhal_lpm_status_t HAL_LpmDev_StopTimer(const lpm_dev_t *dev)\n{\n    int ret = kStatus_HAL_LpmSuccess;\n\n    if (dev->timer == NULL)\n    {\n        return kStatus_HAL_LpmTimerNull;\n    }\n\n    if (xTimerStop(dev->timer, 0) != pdPASS)\n    {\n        ret = kStatus_HAL_LpmTimerFail;\n    }\n\n    return ret;\n}\n\nhal_lpm_status_t HAL_LpmDev_OpenPreEnterSleepTimer(const lpm_dev_t *dev)\n{\n    int ret = kStatus_HAL_LpmSuccess;\n\n    if (dev->preEnterSleepTimer == NULL)\n    {\n        return kStatus_HAL_LpmTimerNull;\n    }\n\n    if (xTimerStart(dev->preEnterSleepTimer, 0) != pdPASS)\n    {\n        ret = kStatus_HAL_LpmTimerFail;\n    }\n\n    return ret;\n}\n\nhal_lpm_status_t HAL_LpmDev_StopPreEnterSleepTimer(const lpm_dev_t *dev)\n{\n    int ret = kStatus_HAL_LpmSuccess;\n\n    if (dev->preEnterSleepTimer == NULL)\n    {\n        return kStatus_HAL_LpmTimerNull;\n    }\n\n    if (xTimerStop(dev->preEnterSleepTimer, 0) != pdPASS)\n    {\n        ret = kStatus_HAL_LpmTimerFail;\n    }\n\n    return ret;\n}\n\nhal_lpm_status_t HAL_LpmDev_EnterSleep(const lpm_dev_t *dev, hal_lpm_mode_t mode)\n{\n    int ret = kStatus_HAL_LpmSuccess;\n    switch (mode)\n    {\n        case kLPMMode_SNVS:\n        {\n            /* put enter SNVS low power mode here*/\n        }\n        break;\n\n        default:\n            break;\n    }\n\n    return ret;\n}\n\nhal_lpm_status_t HAL_LpmDev_Lock(const lpm_dev_t *dev)\n{\n    uint8_t fromISR = __get_IPSR();\n\n    if (dev->lock == NULL)\n    {\n        return kStatus_HAL_LpmLockNull;\n    }\n\n    if (fromISR)\n    {\n        BaseType_t HigherPriorityTaskWoken = pdFALSE;\n        if (xSemaphoreTakeFromISR(dev->lock, &HigherPriorityTaskWoken) != pdPASS)\n        {\n            return kStatus_HAL_LpmLockError;\n        }\n    }\n    else\n    {\n        if (xSemaphoreTake(dev->lock, portMAX_DELAY) != pdPASS)\n        {\n            return kStatus_HAL_LpmLockError;\n        }\n    }\n\n    return kStatus_HAL_LpmSuccess;\n}\n\nhal_lpm_status_t HAL_LpmDev_Unlock(const lpm_dev_t *dev)\n{\n    uint8_t fromISR = __get_IPSR();\n\n    if (dev->lock == NULL)\n    {\n        return kStatus_HAL_LpmLockNull;\n    }\n\n    if (fromISR)\n    {\n        BaseType_t HigherPriorityTaskWoken = pdFALSE;\n        if (xSemaphoreGiveFromISR(dev->lock, &HigherPriorityTaskWoken) != pdPASS)\n        {\n            return kStatus_HAL_LpmLockError;\n        }\n    }\n    else\n    {\n        if (xSemaphoreGive(dev->lock) != pdPASS)\n        {\n            return kStatus_HAL_LpmLockError;\n        }\n    }\n\n    return kStatus_HAL_LpmSuccess;\n}\n\nstatic lpm_dev_operator_t s_LpmDevOperators = {\n    .init              = HAL_LpmDev_Init,\n    .deinit            = HAL_LpmDev_Deinit,\n    .openTimer         = HAL_LpmDev_OpenTimer,\n    .stopTimer         = HAL_LpmDev_StopTimer,\n    .openPreEnterTimer = HAL_LpmDev_OpenPreEnterSleepTimer,\n    .stopPreEnterTimer = HAL_LpmDev_StopPreEnterSleepTimer,\n    .enterSleep        = HAL_LpmDev_EnterSleep,\n    .lock              = HAL_LpmDev_Lock,\n    .unlock            = HAL_LpmDev_Unlock,\n};\n\nstatic lpm_dev_t s_LpmDev = {\n    .id  = 0,\n    .ops = &s_LpmDevOperators,\n};\n\nint HAL_LpmDev_Register()\n{\n    int ret = 0;\n\n    FWK_LpmManager_DeviceRegister(&s_LpmDev);\n\n    return ret;\n}\n')),(0,l.kt)("h3",{id:"requesting-device"},"Requesting Device"),(0,l.kt)("p",null,'As part of this example,\nwe assume an LPM device is running at the same time as a "requesting device" (camera, vision algo,\netc.) of a different type which is performing some critical functionality.'),(0,l.kt)("p",null,'Supposing this example "requesting device" (aptly named "ExampleDev") performs some critical\nfunctionality inside\n',(0,l.kt)("inlineCode",{parentName:"p"},"HAL_InputDev_ExampleDev_Critical")," will set the request busy by calling ",(0,l.kt)("inlineCode",{parentName:"p"},"FWK_LpmManager_RuntimeGet"),",\nthus acquiring the lock which prevents changes to the current power mode state."),(0,l.kt)("p",null,"After the device has completed its critical functionality, it will use use ",(0,l.kt)("inlineCode",{parentName:"p"},"FWK_LpmManager_RuntimePut")," to release the lock which prevents changes to the current power mode state."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},'static hal_lpm_request_t s_LpmReq = {\n    .dev  = &s_InputDev,\n    .name = "lpm device",\n};\n\nint HAL_InputDev_ExampleDev_Critical(void)\n{\n    FWK_LpmManager_RuntimeGet(&s_LpmReq);\n\n    /* perform critical function here */\n\n    FWK_LpmManager_RuntimePut(&s_LpmReq);\n}\n\nint HAL_InputDev_ExampleDev_Register(void)\n{\n    hal_input_status_t status = kStatus_HAL_InputSuccess;\n\n    status = FWK_LpmManager_RegisterRequestHandler(&s_LpmReq);\n\n    return status;\n}\n')))}d.isMDXComponent=!0}}]);