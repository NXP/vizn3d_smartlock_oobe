"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[846],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return h}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=c(n),h=i,u=m["".concat(l,".").concat(h)]||m[h]||p[h]||r;return n?a.createElement(u,o(o({ref:t},d),{},{components:n})):a.createElement(u,o({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2089:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return d},default:function(){return m}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),o=["components"],s={sidebar_position:1},l="Overview",c={unversionedId:"framework/hal-devices/overview",id:"framework/hal-devices/overview",isDocsHomePage:!1,title:"Overview",description:"One of the most important steps in the the creation of any embedded software project is peripheral integration.",source:"@site/docs/framework/hal-devices/overview.md",sourceDirName:"framework/hal-devices",slug:"/framework/hal-devices/overview",permalink:"/vizn3d_smartlock_oobe/docs/framework/hal-devices/overview",editUrl:"https://github.com/nxp/vizn3d_smartlock_oobe/docs/docs/docs/framework/hal-devices/overview.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Audio Processing Manager",permalink:"/vizn3d_smartlock_oobe/docs/framework/device-managers/audio_processing"},next:{title:"Input Devices",permalink:"/vizn3d_smartlock_oobe/docs/framework/hal-devices/input"}},d=[{value:"Device Registration",id:"device-registration",children:[],level:2},{value:"Device Types",id:"device-types",children:[],level:2},{value:"Anatomy of a HAL device",id:"anatomy-of-a-hal-device",children:[{value:"Operators",id:"operators",children:[],level:3}],level:2},{value:"Configs",id:"configs",children:[{value:"name",id:"name",children:[],level:3},{value:"expectedValue",id:"expectedvalue",children:[],level:3},{value:"description",id:"description",children:[],level:3},{value:"value",id:"value",children:[],level:3},{value:"get",id:"get",children:[],level:3},{value:"set",id:"set",children:[],level:3}],level:2}],p={toc:d};function m(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"overview"},"Overview"),(0,r.kt)("p",null,"One of the most important steps in the the creation of any embedded software project is peripheral integration.\nUnfortunately, this step can often be one of the most time intensive steps of the process.\nAdditionally,\nperipheral drivers are often heavily tied to the specific platform which those drivers were originally written for,\nwhich makes upgrading/moving to another platform difficult and costly."),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"Hardware Abstraction Layer (HAL)")," component of the framework architecture was designed in direct response to these issues."),(0,r.kt)("p",null,'HAL devices are designed to be written "on top of" lower level driver code,\nhelping to increase code understandability by abstracting many of the underlying details,\nHAL devices are also designed to be reused across different projects and even different NXP platforms,\nincreasing code reuse which can help cut down on development time.'),(0,r.kt)("h2",{id:"device-registration"},"Device Registration"),(0,r.kt)("p",null,"In order for a manager to communicate with a HAL device,\nthat device must first be registered to its respective manager.\nRegistration of each HAL device takes place at the beginning of application startup when ",(0,r.kt)("inlineCode",{parentName:"p"},"main()")," calls the ",(0,r.kt)("inlineCode",{parentName:"p"},"APP_RegisterHalDevices()")," function as shown below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="source/main.cpp" {10}',title:'"source/main.cpp"',"{10}":!0},'int main(void)\n{\n    /* Init board hardware. */\n    APP_BoardInit();\n    LOGD("[MAIN]:Started");\n    /* init the framework*/\n    APP_InitFramework();\n\n    /* register the hal devices*/\n    APP_RegisterHalDevices();\n\n    /* start the framework*/\n    APP_StartFramework();\n\n    // start\n    vTaskStartScheduler();\n\n    while (1)\n    {\n        LOGD("#");\n    }\n\n    return 0;\n}\n')),(0,r.kt)("p",null,'To register a device to its manager,\neach HAL device implements a registration function which is called prior to starting the managers themselves.\nFor example, the "register" function for the push button input device looks as follows:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="HAL/common/hal_input_push_buttons.c"',title:'"HAL/common/hal_input_push_buttons.c"'},'int HAL_InputDev_PushButtons_Register()\n{\n    int error = 0;\n    LOGD("input_dev_push_buttons_register");\n    error = FWK_InputManager_DeviceRegister(&s_InputDev_PushButtons);\n    return error;\n}\n')),(0,r.kt)("p",null,"Because HAL devices do not have header ",(0,r.kt)("inlineCode",{parentName:"p"},".h")," files associated with them,\nthe registration function for each device is exposed via the ",(0,r.kt)("inlineCode",{parentName:"p"},"board_define.h")," file found inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"boards")," folder.\nEach HAL device to be registered on startup must be added to the ",(0,r.kt)("inlineCode",{parentName:"p"},"APP_RegisterHalDevices")," function in the ",(0,r.kt)("inlineCode",{parentName:"p"},"board_hal_registration.c")," file.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"board_hal_registration.c")," file is also found in the ",(0,r.kt)("inlineCode",{parentName:"p"},"boards")," folder."),(0,r.kt)("h2",{id:"device-types"},"Device Types"),(0,r.kt)("p",null,"There are several different device types to encapsulate the various peripherals which a user may wish to incorporate into their project.\nThese device types include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Input"),(0,r.kt)("li",{parentName:"ul"},"Output"),(0,r.kt)("li",{parentName:"ul"},"Camera"),(0,r.kt)("li",{parentName:"ul"},"Display"),(0,r.kt)("li",{parentName:"ul"},"VAlgo (Vision/Voice)")),(0,r.kt)("p",null,"As well as a few others which are not listed here."),(0,r.kt)("p",null,"Each device type has specific methods and fields based on the unique characteristics of that device type.\nFor example, the camera HAL device definition looks as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="framework/hal_api/hal_camera_dev.h"',title:'"framework/hal_api/hal_camera_dev.h"'},"/**\n * @brief Callback function to notify camera manager that one frame is dequeued\n * @param dev Device structure of the camera device calling this function\n * @param event id of the event that took place\n * @param param Parameters\n * @param fromISR True if this operation takes place in an irq, 0 otherwise\n * @return 0 if the operation was successfully\n */\ntypedef int (*camera_dev_callback_t)(const camera_dev_t *dev, camera_event_t event, void *param, uint8_t fromISR);\n\n/*! @brief Operation that needs to be implemented by a camera device */\ntypedef struct _camera_dev_operator\n{\n    /* initialize the dev */\n    hal_camera_status_t (*init)(camera_dev_t *dev, int width, int height, camera_dev_callback_t callback, void *param);\n    /* deinitialize the dev */\n    hal_camera_status_t (*deinit)(camera_dev_t *dev);\n    /* start the dev */\n    hal_camera_status_t (*start)(const camera_dev_t *dev);\n    /* enqueue a buffer to the dev */\n    hal_camera_status_t (*enqueue)(const camera_dev_t *dev, void *data);\n    /* dequeue a buffer from the dev */\n    hal_camera_status_t (*dequeue)(const camera_dev_t *dev, void **data, pixel_format_t *format);\n    /* postProcess a buffer from the dev */\n    /*\n     * Only do the minimum determination(data point and the format) of the frame in the dequeue.\n     *\n     * And split the CPU based post process(IR/Depth/... processing) to postProcess as they will eat CPU\n     * which is critical for the whole system as camera manager is running with the highest priority.\n     *\n     * Camera manager will do the postProcess if there is a consumer of this frame.\n     *\n     * Note:\n     * Camera manager will call multiple times of the posProcess of the same frame determinted by dequeue.\n     * The HAL driver needs to guarantee the postProcess only do once for the first call.\n     *\n     */\n    hal_camera_status_t (*postProcess)(const camera_dev_t *dev, void **data, pixel_format_t *format);\n    /* input notify */\n    hal_camera_status_t (*inputNotify)(const camera_dev_t *dev, void *data);\n} camera_dev_operator_t;\n\n/*! @brief Structure that characterize the camera device. */\ntypedef struct\n{\n    /* buffer resolution */\n    int height;\n    int width;\n    int pitch;\n    /* active rect */\n    int left;\n    int top;\n    int right;\n    int bottom;\n    /* rotate degree */\n    cw_rotate_degree_t rotate;\n    /* flip */\n    flip_mode_t flip;\n    /* swap byte per two bytes */\n    int swapByte;\n} camera_dev_static_config_t;\n")),(0,r.kt)("p",null,"In many ways, HAL devices can be thought of as similar to interfaces in C++ and other object-oriented languages."),(0,r.kt)("h2",{id:"anatomy-of-a-hal-device"},"Anatomy of a HAL device"),(0,r.kt)("p",null,"HAL devices are made up of several components which can vary by device type.\nHowever,\neach HAL device regardless of type has at least 3 components:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"id")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"name")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#operators"},(0,r.kt)("inlineCode",{parentName:"a"},"operators")))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," field is a unique device identifier which is assigned by the device's manager when the device is first registered."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," field is used to help identify the device during various function calls and when debugging."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"operators")," field is a struct which contains function pointers to each of the functions that the HAL device is required to implement.\nThe operators which a device is required to implement will vary based on the device type."),(0,r.kt)("p",null,"A HAL device's definition is stored in a struct which gets passed to that device's respective manager when the device is registered.\nThis gives the manager information about the device\nand allows the manager to call the device's operators when necessary."),(0,r.kt)("h3",{id:"operators"},"Operators"),(0,r.kt)("p",null,'Operators are functions that "operate" on the device itself,\nand are used by the device\'s manager to control the device and/or augment its behavior.\nOperators are used for initializing, starting, and stopping devices,\nas well as serving many other functions depending on the device.'),(0,r.kt)("p",null,"As mentioned previously,\nthe operators a HAL device must implement varies based on device type.\nFor example,\ninput devices must implement an ",(0,r.kt)("inlineCode",{parentName:"p"},"init"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"deinit"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"start"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"stop"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"inputNotify")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="sln_framework/hal_api/hal_input_dev.h"',title:'"sln_framework/hal_api/hal_input_dev.h"'},"typedef struct\n{\n    /* initialize the dev */\n    hal_input_status_t (*init)(input_dev_t *dev, input_dev_callback_t callback);\n    /* deinitialize the dev */\n    hal_input_status_t (*deinit)(const input_dev_t *dev);\n    /* start the dev */\n    hal_input_status_t (*start)(const input_dev_t *dev);\n    /* stop the dev */\n    hal_input_status_t (*stop)(const input_dev_t *dev);\n    /* notify the input_dev */\n    hal_input_status_t (*inputNotify)(const input_dev_t *dev, void *param);\n} input_dev_operator_t;\n")),(0,r.kt)("p",null,"Generally, each device regardless of type will have at least a ",(0,r.kt)("inlineCode",{parentName:"p"},"start"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"stop"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"init"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"deinit")," function.\nAdditionally,\nmost devices will also implement an ",(0,r.kt)("inlineCode",{parentName:"p"},"inputNotify")," function which is used for ",(0,r.kt)("a",{parentName:"p",href:"/vizn3d_smartlock_oobe/docs/framework/events/event-handlers"},"event handling"),"."),(0,r.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Failing to implement a function will not prevent the HAL device from being registered,\nbut is likely to prevent certain functionality from working.\nFor example,\nfailing to provide an implementation for a HAL device's ",(0,r.kt)("inlineCode",{parentName:"p"},"start")," function will prevent its respective manager from starting that device."))),(0,r.kt)("h2",{id:"configs"},"Configs"),(0,r.kt)("div",{className:"admonition admonition-warning alert alert--danger"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"warning")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"This section describes a feature which is currently being developed."))),(0,r.kt)("p",null,"Configs represent the individual, configurable attributes specific to a HAL device.\nThe configs available for a device varies from device to device,\nbut can be altered during runtime via user input or by other devices and can be saved to flash to retain the same value through power cycles."),(0,r.kt)("p",null,'For example, the HAL device for the IR/White LEDs may only have a "brightness" config, while a speaker device may have configs for "volume", "left/right balance", etc.'),(0,r.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Each device can have a maximum of ",(0,r.kt)("inlineCode",{parentName:"p"},"MAXIMUM_CONFIGS_PER_DEVICE")," configs (see ",(0,r.kt)("inlineCode",{parentName:"p"},"framework/inc/fwk_common.h"),")."))),(0,r.kt)("p",null,"Each device config regardless of device type has the same fields:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#name"},(0,r.kt)("inlineCode",{parentName:"a"},"name"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#expectedValue"},(0,r.kt)("inlineCode",{parentName:"a"},"expectedValue"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#description"},(0,r.kt)("inlineCode",{parentName:"a"},"description"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#value"},(0,r.kt)("inlineCode",{parentName:"a"},"value"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#get"},(0,r.kt)("inlineCode",{parentName:"a"},"get"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#set"},(0,r.kt)("inlineCode",{parentName:"a"},"set")))),(0,r.kt)("h3",{id:"name"},"name"),(0,r.kt)("p",null,"A string containing the name of the config.\nThe string length should be less than DEVICE_CONFIG_NAME_MAX_LENGTH."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"char name[DEVICE_CONFIG_NAME_MAX_LENGTH];\n")),(0,r.kt)("h3",{id:"expectedvalue"},"expectedValue"),(0,r.kt)("p",null,"A string which provides a description of the valid values associated with the config.\nThe length of the string should be less than ",(0,r.kt)("inlineCode",{parentName:"p"},"DEVICE_CONFIG_EXPECTED_VAL_MAX_LENGTH"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"char expectedValue[DEVICE_CONFIG_EXPECTED_VAL_MAX_LENGTH];\n")),(0,r.kt)("h3",{id:"description"},"description"),(0,r.kt)("p",null,"A string which provides a description of the config.\nThe length of the string should be less than DEVICE_CONFIG_DESCRIPTION_MAX_LENGTH."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"char description[DEVICE_CONFIG_DESCRIPTION_MAX_LENGTH];\n")),(0,r.kt)("h3",{id:"value"},"value"),(0,r.kt)("p",null,"An int which stores the internal value of the config.\n",(0,r.kt)("inlineCode",{parentName:"p"},"value")," should be set using the ",(0,r.kt)("inlineCode",{parentName:"p"},"set")," function and retrieved using the ",(0,r.kt)("inlineCode",{parentName:"p"},"get")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"uint32_t value;\n")),(0,r.kt)("h3",{id:"get"},"get"),(0,r.kt)("p",null,"A function which returns the ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," of the config."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"status_t (*get)(char *valueToString);\n")),(0,r.kt)("h3",{id:"set"},"set"),(0,r.kt)("p",null,"A function which sets the ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," of the config."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"status_t (*set)(char *configName, uint32_t value);\n")))}m.isMDXComponent=!0}}]);